using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace PlayFab.ClientModels
{
	
	
	
	public class AddFriendRequest
	{
		
		
		/// <summary>
		/// PlayFab identifier of the user to attempt to add to the local user's friend list
		/// </summary>
		
		public string FriendPlayFabId { get; set;}
		
		/// <summary>
		/// PlayFab username of the user to attempt to add to the local user's friend list
		/// </summary>
		
		public string FriendUsername { get; set;}
		
		/// <summary>
		/// email address of the user to attempt to add to the local user's friend list
		/// </summary>
		
		public string FriendEmail { get; set;}
		
		/// <summary>
		/// title-specific display name of the user to attempt to add to the local user's friend list
		/// </summary>
		
		public string FriendTitleDisplayName { get; set;}
		
	}
	
	
	
	public class AddFriendResult
	{
		
		
		/// <summary>
		/// was the friend request processed successfully
		/// </summary>
		
		public bool Created { get; set;}
		
	}
	
	
	
	public class AndroidDevicePushNotificationRegistrationRequest
	{
		
		
		/// <summary>
		/// unique token generated by the Google Cloud Messaging service when the title registered to receive push notifications
		/// </summary>
		
		public string DeviceToken { get; set;}
		
	}
	
	
	
	public class AndroidDevicePushNotificationRegistrationResult
	{
		
		
	}
	
	
	
	public class CartItem
	{
		
		
		/// <summary>
		/// unique identifier for the catalog item
		/// </summary>
		
		public string ItemId { get; set;}
		
		/// <summary>
		/// class name to which catalog item belongs
		/// </summary>
		
		public string ItemClass { get; set;}
		
		/// <summary>
		/// unique instance identifier for this catalog item
		/// </summary>
		
		public string ItemInstanceId { get; set;}
		
		/// <summary>
		/// display name for the catalog item
		/// </summary>
		
		public string DisplayName { get; set;}
		
		/// <summary>
		/// description of the catalog item
		/// </summary>
		
		public string Description { get; set;}
		
		/// <summary>
		/// the cost of the catalog item for each applicable virtual currency
		/// </summary>
		
		public Dictionary<string,uint> VirtualCurrencyPrices { get; set;}
		
		/// <summary>
		/// the cost of the catalog item for each applicable real world currency
		/// </summary>
		
		public Dictionary<string,uint> RealCurrencyPrices { get; set;}
		
		/// <summary>
		/// the amount of each applicable virtual currency which will be received as a result of purchasing this catalog item
		/// </summary>
		
		public Dictionary<string,uint> VCAmount { get; set;}
		
	}
	
	
	
	public class CatalogItem
	{
		
		
		/// <summary>
		/// internal item name
		/// </summary>
		
		public string ItemId { get; set;}
		
		/// <summary>
		/// class name to which item belongs
		/// </summary>
		
		public string ItemClass { get; set;}
		
		/// <summary>
		/// catalog item we are working against
		/// </summary>
		
		public string CatalogVersion { get; set;}
		
		/// <summary>
		/// displayable item name
		/// </summary>
		
		public string DisplayName { get; set;}
		
		/// <summary>
		/// text description of item
		/// </summary>
		
		public string Description { get; set;}
		
		/// <summary>
		/// Price of this object in virtual currencies
		/// </summary>
		
		public Dictionary<string,uint> VirtualCurrencyPrices { get; set;}
		
		/// <summary>
		/// Price of this object in real money currencies
		/// </summary>
		
		public Dictionary<string,uint> RealCurrencyPrices { get; set;}
		
		/// <summary>
		/// if this object was dropped, when it was dropped (optional)
		/// </summary>
		
		public DateTime? ReleaseDate { get; set;}
		
		/// <summary>
		/// date this object will no longer be viable (optional)
		/// </summary>
		
		public DateTime? ExpirationDate { get; set;}
		
		/// <summary>
		/// is this a free object?
		/// </summary>
		
		public bool? IsFree { get; set;}
		
		/// <summary>
		/// can we buy this object (might be only gettable by being dropped by a monster)
		/// </summary>
		
		public bool? NotForSale { get; set;}
		
		/// <summary>
		/// can we pass this object to someone else?
		/// </summary>
		
		public bool? NotForTrade { get; set;}
		
		/// <summary>
		/// List of item tags
		/// </summary>
		
		public List<string> Tags { get; set;}
		
		/// <summary>
		/// Game specific custom data field (could be json, xml, etc)
		/// </summary>
		
		public string CustomData { get; set;}
		
		/// <summary>
		/// array of unique item Id's that, if the player already has, will automatically place this item in a players inventory
		/// </summary>
		
		public List<string> GrantedIfPlayerHas { get; set;}
		
		/// <summary>
		/// If set, makes this item consumable and sets consumable properties
		/// </summary>
		
		public CatalogItemConsumableInfo Consumable { get; set;}
		
		/// <summary>
		/// If set, makes this item a container and sets container properties
		/// </summary>
		
		public CatalogItemContainerInfo Container { get; set;}
		
		/// <summary>
		/// If set, makes this item a bundle and sets bundle properties
		/// </summary>
		
		public CatalogItemBundleInfo Bundle { get; set;}
		
	}
	
	
	
	public class CatalogItemBundleInfo
	{
		
		
		/// <summary>
		/// array of Unique item id's that this item will grant you once you have this item in your inventory
		/// </summary>
		
		public List<string> BundledItems { get; set;}
		
		/// <summary>
		/// array of result table id's that this item will reference and randomly create items from
		/// </summary>
		
		public List<string> BundledResultTables { get; set;}
		
		/// <summary>
		/// Virtual currencies contained in this item
		/// </summary>
		
		public Dictionary<string,uint> BundledVirtualCurrencies { get; set;}
		
	}
	
	
	
	public class CatalogItemConsumableInfo
	{
		
		
		/// <summary>
		/// number of times this object can be used
		/// </summary>
		
		public uint UsageCount { get; set;}
		
		/// <summary>
		/// duration of how long this item is viable after player aqquires it (in seconds) (optional)
		/// </summary>
		
		public uint? UsagePeriod { get; set;}
		
		/// <summary>
		/// All items that have the same value in this string get their expiration dates added together.
		/// </summary>
		
		public string UsagePeriodGroup { get; set;}
		
	}
	
	
	
	public class CatalogItemContainerInfo
	{
		
		
		/// <summary>
		/// unique item id that, if in posession, the object unlocks and provides the player with content items
		/// </summary>
		
		public string KeyItemId { get; set;}
		
		/// <summary>
		/// array of Unique item id's that this item will grant you once you have opened it
		/// </summary>
		
		public List<string> ItemContents { get; set;}
		
		/// <summary>
		/// array of result table id's that this item will reference and randomly create items from
		/// </summary>
		
		public List<string> ResultTableContents { get; set;}
		
		/// <summary>
		/// Virtual currencies contained in this item
		/// </summary>
		
		public Dictionary<string,uint> VirtualCurrencyContents { get; set;}
		
	}
	
	
	
	public class ConfirmPurchaseRequest
	{
		
		
		/// <summary>
		/// purchase order identifier returned from StartPurchase
		/// </summary>
		
		public string OrderId { get; set;}
		
	}
	
	
	
	public class ConfirmPurchaseResult
	{
		
		
		/// <summary>
		/// purchase order identifier
		/// </summary>
		
		public string OrderId { get; set;}
		
		/// <summary>
		/// date and time of the purchase
		/// </summary>
		
		public DateTime? PurchaseDate { get; set;}
		
		/// <summary>
		/// array of items purchased
		/// </summary>
		
		public List<PurchasedItem> Items { get; set;}
		
	}
	
	
	
	public enum Currency
	{
		USD,
		GBP,
		EUR,
		RUB,
		BRL,
		CIS,
		CAD
	}
	
	
	
	public class CurrentGamesRequest
	{
		
		
		/// <summary>
		/// region we are interested in
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public Region? Region { get; set;}
		
		/// <summary>
		/// version of build we want to get stats for
		/// </summary>
		
		public string BuildVersion { get; set;}
		
		/// <summary>
		/// filter on value of game server instance - running, ended, waiting for players etc.
		/// </summary>
		
		public string IncludeState { get; set;}
		
	}
	
	
	
	public class CurrentGamesResult
	{
		
		
		/// <summary>
		/// array of games the system found
		/// </summary>
		
		public List<GameInfo> Games { get; set;}
		
		/// <summary>
		/// total number of players across all servers
		/// </summary>
		
		public int PlayerCount { get; set;}
		
		/// <summary>
		/// number of games running
		/// </summary>
		
		public int GameCount { get; set;}
		
		/// <summary>
		/// indicates there are some servers it could not get a response for
		/// </summary>
		
		public bool? IncompleteResult { get; set;}
		
	}
	
	
	
	public class FriendInfo
	{
		
		
		/// <summary>
		/// PlayFab unique identifier for this friend
		/// </summary>
		
		public string FriendPlayFabId { get; set;}
		
		/// <summary>
		/// PlayFab unique username for this friend
		/// </summary>
		
		public string Username { get; set;}
		
		/// <summary>
		/// title-specific display name for this friend
		/// </summary>
		
		public string TitleDisplayName { get; set;}
		
		/// <summary>
		/// tags which have been associated with this friend
		/// </summary>
		
		public List<string> Tags { get; set;}
		
		/// <summary>
		/// unique lobby identifier of the Game Server Instance to which this player is currently connected
		/// </summary>
		
		public string CurrentMatchmakerLobbyId { get; set;}
		
		/// <summary>
		/// available Facebook information (if the user and PlayFab friend are also connected in Facebook)
		/// </summary>
		
		public UserFacebookInfo FacebookInfo { get; set;}
		
		/// <summary>
		/// available Steam information (if the user and PlayFab friend are also connected in Steam)
		/// </summary>
		
		public UserSteamInfo SteamInfo { get; set;}
		
		/// <summary>
		/// available Game Center information (if the user and PlayFab friend are also connected in Game Center)
		/// </summary>
		
		public UserGameCenterInfo GameCenterInfo { get; set;}
		
	}
	
	
	
	public class GameInfo
	{
		
		
		/// <summary>
		/// region this server is part of
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public Region? Region { get; set;}
		
		/// <summary>
		/// unique lobby id for this game server
		/// </summary>
		
		public string LobbyID { get; set;}
		
		/// <summary>
		/// build version this server is running
		/// </summary>
		
		public string BuildVersion { get; set;}
		
		/// <summary>
		/// game mode this server is running
		/// </summary>
		
		public string GameMode { get; set;}
		
		/// <summary>
		/// level name this server is running (if appropriate)
		/// </summary>
		
		public string Map { get; set;}
		
		/// <summary>
		/// maximum players this server can support
		/// </summary>
		
		public int MaxPlayers { get; set;}
		
		/// <summary>
		/// array of strings of current player names on this server (note, these are usernames, which means they are account names, not display names)
		/// </summary>
		
		public List<string> PlayerUsernames { get; set;}
		
		/// <summary>
		/// duration this server has been running (in seconds)
		/// </summary>
		
		public uint RunTime { get; set;}
		
		/// <summary>
		/// game specific string denoting server configuration
		/// </summary>
		
		public string GameServerState { get; set;}
		
		/// <summary>
		/// unique client provided string - passed in at start game request - that details user defined specifics about this game server instance
		/// </summary>
		
		public string TitleData { get; set;}
		
	}
	
	
	
	public class GameModeInfo
	{
		
		
		/// <summary>
		/// mode game server is running in - defaults to 0 if there is only one mode
		/// </summary>
		
		public string GameMode { get; set;}
		
		/// <summary>
		/// number of game servers running
		/// </summary>
		
		public uint GameCount { get; set;}
		
		/// <summary>
		/// number of plaer
		/// </summary>
		
		public uint GamePlayersCount { get; set;}
		
	}
	
	
	
	public class GameServerRegionsRequest
	{
		
		
		/// <summary>
		/// version of build we want to get stats for
		/// </summary>
		
		public string BuildVersion { get; set;}
		
		/// <summary>
		/// is the specific game ID granted by PlayFab via the website, found on the end of the URL once you are logged in and looking at a specific game
		/// </summary>
		
		public string TitleId { get; set;}
		
	}
	
	
	
	public class GameServerRegionsResult
	{
		
		
		/// <summary>
		/// array of regions found matching the request parameters
		/// </summary>
		
		public List<RegionInfo> Regions { get; set;}
		
	}
	
	
	
	public class GetAccountInfoRequest
	{
		
		
	}
	
	
	
	public class GetAccountInfoResult
	{
		
		
		/// <summary>
		/// account information for the local user
		/// </summary>
		
		public UserAccountInfo AccountInfo { get; set;}
		
	}
	
	
	
	public class GetCatalogItemsRequest
	{
		
		
		/// <summary>
		/// which catalog is being requested
		/// </summary>
		
		public string CatalogVersion { get; set;}
		
	}
	
	
	
	public class GetCatalogItemsResult
	{
		
		
		/// <summary>
		/// array of inventory objects
		/// </summary>
		
		public List<CatalogItem> Catalog { get; set;}
		
	}
	
	
	
	public class GetFriendsListRequest
	{
		
		
		/// <summary>
		/// indicates whether Steam service friends should also be included in the response
		/// </summary>
		
		public bool? IncludeSteamFriends { get; set;}
		
	}
	
	
	
	public class GetFriendsListResult
	{
		
		
		/// <summary>
		/// array of friends found
		/// </summary>
		
		public List<FriendInfo> Friends { get; set;}
		
	}
	
	
	
	public class GetTitleDataRequest
	{
		
		
		/// <summary>
		///  array of keys to get back data from the TitleData data blob, set by the admin tools
		/// </summary>
		
		public List<string> Keys { get; set;}
		
	}
	
	
	
	public class GetTitleDataResult
	{
		
		
		/// <summary>
		/// a dictionary object of key / value pairs
		/// </summary>
		
		public Dictionary<string,string> Data { get; set;}
		
	}
	
	
	
	public class GetTitleNewsRequest
	{
		
		
		/// <summary>
		/// limits the results to the last n entries (defaults to 10 if not set)
		/// </summary>
		
		public uint? Count { get; set;}
		
	}
	
	
	
	public class GetTitleNewsResult
	{
		
		
		/// <summary>
		/// array of news items
		/// </summary>
		
		public List<TitleNewsItem> News { get; set;}
		
	}
	
	
	
	public class GetUserDataRequest
	{
		
		
		/// <summary>
		/// specific keys to search for in the custom user data
		/// </summary>
		
		public List<string> Keys { get; set;}
		
	}
	
	
	
	public class GetUserDataResult
	{
		
		
		/// <summary>
		/// user specific data for this title
		/// </summary>
		
		public Dictionary<string,string> Data { get; set;}
		
	}
	
	
	
	public class GetUserInventoryRequest
	{
		
		
	}
	
	
	
	public class GetUserInventoryResult
	{
		
		
		/// <summary>
		/// array of inventory items in the user's current inventory
		/// </summary>
		
		public List<ItemInstance> Inventory { get; set;}
		
		/// <summary>
		/// array of virtual currency balance(s) belonging to the user
		/// </summary>
		
		public Dictionary<string,int> VirtualCurrency { get; set;}
		
	}
	
	
	
	public class ItemInstance
	{
		
		
		/// <summary>
		/// Object name
		/// </summary>
		
		public string ItemId { get; set;}
		
		/// <summary>
		/// unique item id
		/// </summary>
		
		public string ItemInstanceId { get; set;}
		
		/// <summary>
		/// class name object belongs to
		/// </summary>
		
		public string ItemClass { get; set;}
		
		/// <summary>
		/// date purchased
		/// </summary>
		
		public string PurchaseDate { get; set;}
		
		/// <summary>
		/// date object will expire (optional)
		/// </summary>
		
		public string Expiration { get; set;}
		
		/// <summary>
		/// number of remaining uses (optional)
		/// </summary>
		
		public uint? RemainingUses { get; set;}
		
		/// <summary>
		/// game specific comment
		/// </summary>
		
		public string Annotation { get; set;}
		
		/// <summary>
		/// catalog version that this item is part of
		/// </summary>
		
		public string CatalogVersion { get; set;}
		
		/// <summary>
		/// Unique ID of the parent of where this item may have come from (e.g. if it comes from a crate or coupon)
		/// </summary>
		
		public string BundleParent { get; set;}
		
	}
	
	
	
	public class ItemPuchaseRequest
	{
		
		
		/// <summary>
		/// ItemId of the item to purchase
		/// </summary>
		
		public string ItemId { get; set;}
		
		/// <summary>
		/// How many to buy
		/// </summary>
		
		public uint Quantity { get; set;}
		
		/// <summary>
		/// Annotation text about this purchase
		/// </summary>
		
		public string Annotation { get; set;}
		
		/// <summary>
		/// What items to upgrade
		/// </summary>
		
		public List<string> UpgradeFromItems { get; set;}
		
	}
	
	
	
	public class LinkFacebookAccountRequest
	{
		
		
		/// <summary>
		/// unique identifier from Facebook for the user
		/// </summary>
		
		public string AccessToken { get; set;}
		
	}
	
	
	
	public class LinkFacebookAccountResult
	{
		
		
	}
	
	
	
	public class LinkGameCenterAccountRequest
	{
		
		
		/// <summary>
		/// Game Center identifier for the player account to be linked
		/// </summary>
		
		public string GameCenterId { get; set;}
		
	}
	
	
	
	public class LinkGameCenterAccountResult
	{
		
		
	}
	
	
	
	public class LinkSteamAccountRequest
	{
		
		
		/// <summary>
		/// unique identifier from Steam for the user
		/// </summary>
		
		public string SteamTicket { get; set;}
		
	}
	
	
	
	public class LinkSteamAccountResult
	{
		
		
	}
	
	
	
	public class LogEventRequest
	{
		
		
		
		public string eventName { get; set;}
		
		
		public Dictionary<string,object> Body { get; set;}
		
	}
	
	
	
	public class LogEventResult
	{
		
		
		
		public List<string> errors { get; set;}
		
	}
	
	
	
	public class LoginResult
	{
		
		
		/// <summary>
		/// a unique token identifying the user and game at the server level, for the current session
		/// </summary>
		
		public string SessionTicket { get; set;}
		
	}
	
	
	
	public class LoginWithAndroidDeviceIDRequest
	{
		
		
		/// <summary>
		/// unique identifier for the title, found in the URL on the PlayFab developer site as "TitleId=[n]" when a title has been selected
		/// </summary>
		
		public string TitleId { get; set;}
		
		/// <summary>
		/// Android device identifier for the user's device
		/// </summary>
		
		public string AndroidDeviceId { get; set;}
		
		/// <summary>
		/// specific Operating System version for the user's device
		/// </summary>
		
		public string OS { get; set;}
		
		/// <summary>
		/// specific model of the user's device
		/// </summary>
		
		public string AndroidDevice { get; set;}
		
		/// <summary>
		/// automatically create a PlayFab account if one is not currently linked to this iOS device
		/// </summary>
		
		public bool CreateAccount { get; set;}
		
	}
	
	
	
	public class LoginWithFacebookRequest
	{
		
		
		/// <summary>
		/// unique identifier for the title, found in the URL on the PlayFab developer site as "TitleId=[n]" when a title has been selected
		/// </summary>
		
		public string TitleId { get; set;}
		
		/// <summary>
		/// unique identifier from Facebook for the user
		/// </summary>
		
		public string AccessToken { get; set;}
		
		/// <summary>
		/// automatically create a PlayFab account if one is not currently linked to this Facebook account
		/// </summary>
		
		public bool CreateAccount { get; set;}
		
	}
	
	
	
	public class LoginWithGoogleAccountRequest
	{
		
		
		
		public string TitleId { get; set;}
		
		
		public string AccessToken { get; set;}
		
	}
	
	
	
	public class LoginWithIOSDeviceIDRequest
	{
		
		
		/// <summary>
		/// unique identifier for the title, found in the URL on the PlayFab developer site as "TitleId=[n]" when a title has been selected
		/// </summary>
		
		public string TitleId { get; set;}
		
		/// <summary>
		/// vendor-specific iOS identifier for the user's device
		/// </summary>
		
		public string DeviceId { get; set;}
		
		/// <summary>
		/// specific Operating System version for the user's device
		/// </summary>
		
		public string OS { get; set;}
		
		/// <summary>
		/// specific model of the user's device
		/// </summary>
		
		public string DeviceModel { get; set;}
		
		/// <summary>
		/// automatically create a PlayFab account if one is not currently linked to this iOS device
		/// </summary>
		
		public bool CreateAccount { get; set;}
		
	}
	
	
	
	public class LoginWithPlayFabRequest
	{
		
		
		/// <summary>
		/// unique identifier for the title, found in the URL on the PlayFab developer site as "TitleId=[n]" when a title has been selected
		/// </summary>
		
		public string TitleId { get; set;}
		
		/// <summary>
		/// PlayFab username for the account to be signed in (3-24 characters)
		/// </summary>
		
		public string Username { get; set;}
		
		/// <summary>
		/// password for the account to be signed in (6-24 characters)
		/// </summary>
		
		public string Password { get; set;}
		
	}
	
	
	
	public class LoginWithSteamRequest
	{
		
		
		/// <summary>
		/// unique identifier for the title, found in the URL on the PlayFab developer site as "TitleId=[n]" when a title has been selected
		/// </summary>
		
		public string TitleId { get; set;}
		
		/// <summary>
		/// unique identifier from Steam for the user
		/// </summary>
		
		public string SteamTicket { get; set;}
		
		/// <summary>
		/// automatically create a PlayFab account if one is not currently linked to this Steam account
		/// </summary>
		
		public bool CreateAccount { get; set;}
		
	}
	
	
	
	public class MatchmakeRequest
	{
		
		
		/// <summary>
		/// build version we want to match make against
		/// </summary>
		
		public string BuildVersion { get; set;}
		
		/// <summary>
		/// region we want to match make against
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public Region? Region { get; set;}
		
		/// <summary>
		/// game mode we want to match make against
		/// </summary>
		
		public string GameMode { get; set;}
		
		/// <summary>
		/// lobby ID we want to match make against (i.e. selecting a specific server)
		/// </summary>
		
		public string LobbyId { get; set;}
		
		/// <summary>
		/// if specified match specified is full, allow the user to wait in a queue to join. NOTE - only valid if LobbyId is specified
		/// </summary>
		
		public bool? EnableQueue { get; set;}
		
	}
	
	
	
	public class MatchmakeResult
	{
		
		
		/// <summary>
		/// unique lobby id of server we made a match against
		/// </summary>
		
		public string LobbyID { get; set;}
		
		/// <summary>
		/// server IP address we made a match against
		/// </summary>
		
		public string ServerHostname { get; set;}
		
		/// <summary>
		/// port number server communicates on
		/// </summary>
		
		public uint? ServerPort { get; set;}
		
		/// <summary>
		/// if server uses http connection protocols, this is the port it uses
		/// </summary>
		
		public uint? WebSocketPort { get; set;}
		
		/// <summary>
		/// server authorisation ticket - used by RedeemCoupon to validate user insertion into the game
		/// </summary>
		
		public string Ticket { get; set;}
		
		/// <summary>
		/// time/date the server expires on
		/// </summary>
		
		public string Expires { get; set;}
		
		/// <summary>
		/// UNKNOWN - unused in code
		/// </summary>
		
		public uint? PollWaitTimeMS { get; set;}
		
		/// <summary>
		/// result of match making process
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public MatchmakeStatus? Status { get; set;}
		
		/// <summary>
		/// queue of unique user Id's of players waiting to join this game. This user will be at the end of this list.
		/// </summary>
		
		public List<string> Queue { get; set;}
		
	}
	
	
	
	public enum MatchmakeStatus
	{
		Complete,
		Waiting,
		GameNotFound
	}
	
	
	
	public class PayForPurchaseRequest
	{
		
		
		/// <summary>
		/// purchase order identifier returned from StartPurchase
		/// </summary>
		
		public string OrderId { get; set;}
		
		/// <summary>
		/// payment provider to use to fund the purchase
		/// </summary>
		
		public string ProviderName { get; set;}
		
		/// <summary>
		/// currency to use to fund the purchase
		/// </summary>
		
		public string Currency { get; set;}
		
	}
	
	
	
	public class PayForPurchaseResult
	{
		
		
		/// <summary>
		/// purchase order identifier
		/// </summary>
		
		public string OrderId { get; set;}
		
		/// <summary>
		/// status of the transaction
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public TransactionStatus? Status { get; set;}
		
		/// <summary>
		/// virtual currency cost of the transaction
		/// </summary>
		
		public Dictionary<string,int> VCAmount { get; set;}
		
		/// <summary>
		/// real world currency for the transaction
		/// </summary>
		
		public string PurchaseCurrency { get; set;}
		
		/// <summary>
		/// real world cost of the transaction
		/// </summary>
		
		public uint PurchasePrice { get; set;}
		
		/// <summary>
		/// local credit applied to the transaction (provider specific)
		/// </summary>
		
		public uint CreditApplied { get; set;}
		
		/// <summary>
		/// provider used for the transaction
		/// </summary>
		
		public string ProviderData { get; set;}
		
		/// <summary>
		/// url to the purchase provider page that details the purchase
		/// </summary>
		
		public string PurchaseConfirmationPageURL { get; set;}
		
		/// <summary>
		/// current virtual currency totals for the user
		/// </summary>
		
		public Dictionary<string,int> VirtualCurrency { get; set;}
		
	}
	
	
	
	public class PaymentOption
	{
		
		
		
		public string Currency { get; set;}
		
		
		public string ProviderName { get; set;}
		
		
		public uint Price { get; set;}
		
		
		public uint StoreCredit { get; set;}
		
	}
	
	
	
	public class PlaylistInfo
	{
		
		
		/// <summary>
		/// unique id of a playlist
		/// </summary>
		
		public string PlaylistId { get; set;}
		
		/// <summary>
		/// number of games running on this region
		/// </summary>
		
		public uint GameCount { get; set;}
		
		/// <summary>
		/// number of players inside this region
		/// </summary>
		
		public uint GamePlayersCount { get; set;}
		
	}
	
	
	
	public class PurchasedItem
	{
		
		
		/// <summary>
		/// unique instance identifier for this catalog item
		/// </summary>
		
		public string ItemInstanceId { get; set;}
		
		/// <summary>
		/// unique identifier for the catalog item
		/// </summary>
		
		public string ItemId { get; set;}
		
		/// <summary>
		/// catalog version for the item purchased
		/// </summary>
		
		public string CatalogVersion { get; set;}
		
		/// <summary>
		/// display name for the catalog item
		/// </summary>
		
		public string DisplayName { get; set;}
		
		/// <summary>
		/// currency type for the cost of the catalog item
		/// </summary>
		
		public string UnitCurrency { get; set;}
		
		/// <summary>
		/// cost of the catalog item in the given currency
		/// </summary>
		
		public uint UnitPrice { get; set;}
		
		/// <summary>
		/// array of unique items that were awarded when this catalog item was purchased
		/// </summary>
		
		public List<string> BundleContents { get; set;}
		
	}
	
	
	
	public class PurchaseItemRequest
	{
		
		
		/// <summary>
		/// ItemId of the item to purchase
		/// </summary>
		
		public string ItemId { get; set;}
		
		/// <summary>
		/// Virtual currency to use to purchase the item
		/// </summary>
		
		public string VirtualCurrency { get; set;}
		
		/// <summary>
		/// Price the client expects to pay for the item. Required to validate that the price hasn't changed.
		/// </summary>
		
		public int Price { get; set;}
		
		/// <summary>
		/// catalog version for the items to be purchased (defaults to most recent version
		/// </summary>
		
		public string CatalogVersion { get; set;}
		
	}
	
	
	
	public class PurchaseItemResult
	{
		
		
		/// <summary>
		/// Items purchased. (If you purchase a bundle, you can get multiple items as a result
		/// </summary>
		
		public List<PurchasedItem> Items { get; set;}
		
	}
	
	
	
	public class RedeemCouponRequest
	{
		
		
		/// <summary>
		/// generated coupon code to redeem
		/// </summary>
		
		public string CouponCode { get; set;}
		
		/// <summary>
		/// catalog version of the coupon
		/// </summary>
		
		public string CatalogVersion { get; set;}
		
	}
	
	
	
	public class RedeemCouponResult
	{
		
		
		/// <summary>
		/// array of items granted to the player as a result of redeeming the coupon
		/// </summary>
		
		public List<ItemInstance> GrantedItems { get; set;}
		
	}
	
	
	
	public enum Region
	{
		USWest,
		USCentral,
		USEast,
		EUWest,
		APSouthEast,
		APNorthEast,
		SAEast,
		Australia,
		China,
		UberLan
	}
	
	
	
	public class RegionInfo
	{
		
		
		/// <summary>
		/// region we refer to
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public Region? Region { get; set;}
		
		/// <summary>
		/// name of region
		/// </summary>
		
		public string Name { get; set;}
		
		/// <summary>
		/// is this region available for usage (e.g. adding a server, or adding players)
		/// </summary>
		
		public bool Available { get; set;}
		
		/// <summary>
		/// url to ping to get rountrip time
		/// </summary>
		
		public string PingUrl { get; set;}
		
		/// <summary>
		/// number of games / servers running on this region
		/// </summary>
		
		public uint GameCount { get; set;}
		
		/// <summary>
		/// number of players in this region
		/// </summary>
		
		public uint GamePlayersCount { get; set;}
		
		/// <summary>
		/// list of game modes being supported by servers in this region
		/// </summary>
		
		public List<GameModeInfo> GameModes { get; set;}
		
	}
	
	
	
	public class RegionPlaylistsRequest
	{
		
		
		/// <summary>
		/// version of build we want to get stats for
		/// </summary>
		
		public string BuildVersion { get; set;}
		
		/// <summary>
		/// region we are interested in
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public Region Region { get; set;}
		
		/// <summary>
		/// is the specific game ID granted by PlayFab via the website, found on the end of the URL once you are logged in and looking at a specific game
		/// </summary>
		
		public string TitleId { get; set;}
		
	}
	
	
	
	public class RegionPlaylistsResult
	{
		
		
		/// <summary>
		/// array of games in regions found matching the request parameters
		/// </summary>
		
		public List<PlaylistInfo> Playlists { get; set;}
		
	}
	
	
	
	public class RegisterForIOSPushNotificationRequest
	{
		
		
		/// <summary>
		/// unique token generated by the Apple Push Notification service when the title registered to receive push notifications
		/// </summary>
		
		public string DeviceToken { get; set;}
		
	}
	
	
	
	public class RegisterForIOSPushNotificationResult
	{
		
		
	}
	
	
	
	public class RegisterPlayFabUserRequest
	{
		
		
		/// <summary>
		/// unique identifier for the title, found in the URL on the PlayFab developer site as "TitleId=[n]" when a title has been selected
		/// </summary>
		
		public string TitleId { get; set;}
		
		/// <summary>
		/// PlayFab username for the account to be signed in (3-24 characters)
		/// </summary>
		
		public string Username { get; set;}
		
		/// <summary>
		/// user email address, used for account password recovery
		/// </summary>
		
		public string Email { get; set;}
		
		/// <summary>
		/// password for the account to be signed in (6-24 characters)
		/// </summary>
		
		public string Password { get; set;}
		
		/// <summary>
		/// optional string indicating where this user came from (iOS iPhone, Android, etc.)
		/// </summary>
		
		public string Origination { get; set;}
		
	}
	
	
	
	public class RegisterPlayFabUserResult
	{
		
		
		/// <summary>
		/// PlayFab unique identifier for this newly created account
		/// </summary>
		
		public string PlayFabId { get; set;}
		
		/// <summary>
		/// a unique token identifying the user and game at the server level, for the current session
		/// </summary>
		
		public string SessionTicket { get; set;}
		
		/// <summary>
		/// PlayFab unique user name
		/// </summary>
		
		public string Username { get; set;}
		
	}
	
	
	
	public class RemoveFriendRequest
	{
		
		
		/// <summary>
		/// PlayFab identifier of the friend account which is to be removed
		/// </summary>
		
		public string FriendPlayFabId { get; set;}
		
	}
	
	
	
	public class RemoveFriendResult
	{
		
		
	}
	
	
	
	public class SendAccountRecoveryEmailRequest
	{
		
		
		/// <summary>
		/// user email address, used for account password recovery
		/// </summary>
		
		public string Email { get; set;}
		
		/// <summary>
		/// unique identifier for the title, found in the URL on the PlayFab developer site as "TitleId=[n]" when a title has been selected
		/// </summary>
		
		public string TitleId { get; set;}
		
	}
	
	
	
	public class SendAccountRecoveryEmailResult
	{
		
		
	}
	
	
	
	public class SetFriendTagsRequest
	{
		
		
		/// <summary>
		/// PlayFab identifier of the friend account to which the tag(s) should be applied
		/// </summary>
		
		public string FriendPlayFabId { get; set;}
		
		/// <summary>
		/// array of tags to set on the friend account
		/// </summary>
		
		public List<string> Tags { get; set;}
		
	}
	
	
	
	public class SetFriendTagsResult
	{
		
		
	}
	
	
	
	public class StartGameRequest
	{
		
		
		/// <summary>
		/// which uploaded build of the game server we are starting up
		/// </summary>
		
		public string BuildVersion { get; set;}
		
		/// <summary>
		/// the region we want to associate this server with for filtering servers
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public Region Region { get; set;}
		
		/// <summary>
		/// which user defined game mode this server is going to be running (e.g. Capture The Flag = 0, Deathmatch = 1) - default to 0 if there is only one mode
		/// </summary>
		
		public string GameMode { get; set;}
		
		/// <summary>
		/// Is there a password associated with this server?
		/// </summary>
		
		public bool PasswordRestricted { get; set;}
		
		/// <summary>
		/// Lobby Id that the user came from from within the match maker service
		/// </summary>
		
		public string ReplayLobbyId { get; set;}
		
	}
	
	
	
	public class StartGameResult
	{
		
		
		/// <summary>
		/// unique ID for the lobby of the server started.
		/// </summary>
		
		public string LobbyID { get; set;}
		
		/// <summary>
		/// server IP address.
		/// </summary>
		
		public string ServerHostname { get; set;}
		
		/// <summary>
		/// port on server used for communication
		/// </summary>
		
		public uint? ServerPort { get; set;}
		
		/// <summary>
		/// unique ID for this server used in certain API calls
		/// </summary>
		
		public string Ticket { get; set;}
		
		/// <summary>
		/// expiration date, if appropriate
		/// </summary>
		
		public string Expires { get; set;}
		
		/// <summary>
		/// password to log in with
		/// </summary>
		
		public string Password { get; set;}
		
	}
	
	
	
	public class StartPurchaseRequest
	{
		
		
		/// <summary>
		/// catalog version for the items to be purchased
		/// </summary>
		
		public string CatalogVersion { get; set;}
		
		/// <summary>
		/// the set of items to purchase
		/// </summary>
		
		public List<ItemPuchaseRequest> Items { get; set;}
		
	}
	
	
	
	public class StartPurchaseResult
	{
		
		
		/// <summary>
		/// purchase order identifier
		/// </summary>
		
		public string OrderId { get; set;}
		
		/// <summary>
		/// cart items to be purchased
		/// </summary>
		
		public List<CartItem> Contents { get; set;}
		
		/// <summary>
		/// available methods by which the user can pay
		/// </summary>
		
		public List<PaymentOption> PaymentOptions { get; set;}
		
		/// <summary>
		/// current virtual currency totals for the user
		/// </summary>
		
		public Dictionary<string,int> VirtualCurrencyBalances { get; set;}
		
	}
	
	
	
	public enum TitleActivationStatus
	{
		None,
		ActivatedTitleKey,
		PendingSteam,
		ActivatedSteam,
		RevokedSteam
	}
	
	
	
	public class TitleNewsItem
	{
		
		
		/// <summary>
		/// date and time when the news items was posted
		/// </summary>
		
		public DateTime? Timestamp { get; set;}
		
		/// <summary>
		/// title of the news item
		/// </summary>
		
		public string Title { get; set;}
		
		/// <summary>
		/// news item text
		/// </summary>
		
		public string Body { get; set;}
		
	}
	
	
	
	public enum TransactionStatus
	{
		CreateCart,
		Init,
		Approved,
		Succeeded,
		FailedByProvider,
		RefundPending,
		Refunded,
		RefundFailed,
		ChargedBack,
		FailedByUber,
		Revoked,
		TradePending,
		Upgraded,
		Other,
		Failed
	}
	
	
	
	public class UnlinkFacebookAccountRequest
	{
		
		
	}
	
	
	
	public class UnlinkFacebookAccountResult
	{
		
		
	}
	
	
	
	public class UnlinkGameCenterAccountRequest
	{
		
		
	}
	
	
	
	public class UnlinkGameCenterAccountResult
	{
		
		
	}
	
	
	
	public class UnlinkSteamAccountResult
	{
		
		
	}
	
	
	
	public class UnlockContainerItemRequest
	{
		
		
		/// <summary>
		/// unique identifier of the container to attempt to unlock
		/// </summary>
		
		public string ContainerItemId { get; set;}
		
		/// <summary>
		/// catalog version of the container
		/// </summary>
		
		public string CatalogVersion { get; set;}
		
	}
	
	
	
	public class UnlockContainerItemResult
	{
		
		
		/// <summary>
		/// Unique instance id of the container unlocked
		/// </summary>
		
		public string UnlockedItemInstanceId { get; set;}
		
		/// <summary>
		/// Unique item instance id of the key used to unlock it, if applicable
		/// </summary>
		
		public string UnlockedWithItemInstanceId { get; set;}
		
		/// <summary>
		/// array of items granted to the player as a result of unlocking the container
		/// </summary>
		
		public List<ItemInstance> GrantedItems { get; set;}
		
		/// <summary>
		/// virtual currency granted to the player as a result of unlocking the container
		/// </summary>
		
		public Dictionary<string,uint> VirtualCurrency { get; set;}
		
	}
	
	
	
	public class UpdateEmailAddressRequest
	{
		
		
		/// <summary>
		/// user email address, used for account password recovery
		/// </summary>
		
		public string Email { get; set;}
		
	}
	
	
	
	public class UpdateEmailAddressResult
	{
		
		
	}
	
	
	
	public class UpdatePasswordRequest
	{
		
		
		/// <summary>
		/// password for the account to be signed in (6-24 characters)
		/// </summary>
		
		public string Password { get; set;}
		
	}
	
	
	
	public class UpdatePasswordResult
	{
		
		
	}
	
	
	
	public class UpdateUserDataRequest
	{
		
		
		/// <summary>
		/// data to be written to the user's custom data
		/// </summary>
		
		public Dictionary<string,string> Data { get; set;}
		
	}
	
	
	
	public class UpdateUserDataResult
	{
		
		
	}
	
	
	
	public class UpdateUserTitleDisplayNameRequest
	{
		
		
		/// <summary>
		/// new title display name for the user - must be between 3 and 25 characters
		/// </summary>
		
		public string DisplayName { get; set;}
		
	}
	
	
	
	public class UpdateUserTitleDisplayNameResult
	{
		
		
		/// <summary>
		/// current title display name for the user (this will be the original display name if the rename attempt failed)
		/// </summary>
		
		public string DisplayName { get; set;}
		
	}
	
	
	
	public class UserAccountInfo
	{
		
		
		/// <summary>
		/// unique id for account
		/// </summary>
		
		public string PlayFabId { get; set;}
		
		/// <summary>
		/// time / date account was created
		/// </summary>
		
		public DateTime? Created { get; set;}
		
		/// <summary>
		/// account name
		/// </summary>
		
		public string Username { get; set;}
		
		/// <summary>
		/// specific game title information
		/// </summary>
		
		public UserTitleInfo TitleInfo { get; set;}
		
		/// <summary>
		/// user's private account into
		/// </summary>
		
		public UserPrivateAccountInfo PrivateInfo { get; set;}
		
		/// <summary>
		/// facebook information (if linked)
		/// </summary>
		
		public UserFacebookInfo FacebookInfo { get; set;}
		
		/// <summary>
		/// steam information (if linked)
		/// </summary>
		
		public UserSteamInfo SteamInfo { get; set;}
		
		/// <summary>
		/// gamecenter information (if linked)
		/// </summary>
		
		public UserGameCenterInfo GameCenterInfo { get; set;}
		
	}
	
	
	
	public class UserFacebookInfo
	{
		
		
		/// <summary>
		/// facebook id
		/// </summary>
		
		public string FacebookId { get; set;}
		
		/// <summary>
		/// facebook username
		/// </summary>
		
		public string FacebookUsername { get; set;}
		
		/// <summary>
		/// facebook display name
		/// </summary>
		
		public string FacebookDisplayname { get; set;}
		
	}
	
	
	
	public class UserGameCenterInfo
	{
		
		
		/// <summary>
		/// gamecenter id if account is linked
		/// </summary>
		
		public string GameCenterId { get; set;}
		
	}
	
	
	
	public enum UserOrigination
	{
		Organic,
		Steam,
		Google,
		Amazon,
		Facebook,
		Kongregate,
		GamersFirst,
		Unknown,
		IOS,
		LoadTest,
		Android
	}
	
	
	
	public class UserPrivateAccountInfo
	{
		
		
		/// <summary>
		/// Email address
		/// </summary>
		
		public string Email { get; set;}
		
	}
	
	
	
	public class UserSteamInfo
	{
		
		
		/// <summary>
		/// steam id
		/// </summary>
		
		public string SteamId { get; set;}
		
		/// <summary>
		/// if account is linked to steam, this is the country that steam reports the player being in
		/// </summary>
		
		public string SteamCountry { get; set;}
		
		/// <summary>
		/// Currency set in the user's steam account
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public Currency? SteamCurrency { get; set;}
		
		/// <summary>
		/// STEAM specific - what stage of game ownership is the user at with Steam
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public TitleActivationStatus? SteamActivationStatus { get; set;}
		
	}
	
	
	
	public class UserTitleInfo
	{
		
		
		/// <summary>
		/// displayable game name
		/// </summary>
		
		public string DisplayName { get; set;}
		
		/// <summary>
		/// optional value that details where the user originated
		/// </summary>
		[JsonConverter(typeof(StringEnumConverter))]
		public UserOrigination? Origination { get; set;}
		
		/// <summary>
		/// When this object was created. Title specific reporting for user creation time should be done against this rather than the User created field since account creation can differ significantly between title registration.
		/// </summary>
		
		public DateTime? Created { get; set;}
		
		/// <summary>
		/// Last time the user logged in to this title
		/// </summary>
		
		public DateTime? LastLogin { get; set;}
		
		/// <summary>
		///  Time the user first logged in. This can be different from when the UTD was created. For example we create a UTD when issuing a beta key. An arbitrary amount of time can pass before the user actually logs in.
		/// </summary>
		
		public DateTime? FirstLogin { get; set;}
		
	}
	
	
	
	public class ValidateGooglePlayPurchaseRequest
	{
		
		
		
		public string packageName { get; set;}
		
		
		public string productId { get; set;}
		
		
		public string purchaseToken { get; set;}
		
		/// <summary>
		/// OAuth 2.0 token retrieved from Google
		/// </summary>
		
		public string accessToken { get; set;}
		
	}
	
	
	
	public class ValidateGooglePlayPurchaseResult
	{
		
		
		
		public string kind { get; set;}
		
		
		public DateTime? purchaseTime { get; set;}
		
		
		public int puchaseState { get; set;}
		
		
		public int consumptionState { get; set;}
		
		
		public string developerPayload { get; set;}
		
	}
	
	
	
	public class ValidateIOSReceiptRequest
	{
		
		
		/// <summary>
		/// base64 encoded receipt data, passed back by the App Store as a result of a successful purchase
		/// </summary>
		
		public string ReceiptData { get; set;}
		
		/// <summary>
		/// name of the object purchased
		/// </summary>
		
		public string ObjectName { get; set;}
		
		/// <summary>
		/// currency used for the purchase
		/// </summary>
		
		public string CurrencyCode { get; set;}
		
		/// <summary>
		/// amount of the stated currency paid for the object
		/// </summary>
		
		public uint PurchasePrice { get; set;}
		
	}
	
	
	
	public class ValidateIOSReceiptResult
	{
		
		
	}
	
}
